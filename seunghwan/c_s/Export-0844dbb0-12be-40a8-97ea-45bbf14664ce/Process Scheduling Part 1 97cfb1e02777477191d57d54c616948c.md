# Process Scheduling Part.1

프로세스 스케줄링?

프로세스 스케줄링을 왜 해야 하는가?

- 다중프로그래밍
    - 여러개의 프로세스가 시스템 내 존재
    - 자원을 할당 할 프로세스를 선택 해야 함
        - 스케줄링이라 한다
    - 자원을 나눠주는 방법
        - 시간 분할 관리
            - 하나의 자원을 여러 스레드들이 번갈아 가며 사용
            - 예) 프로세서
            - 프로세스 스케줄링
                - 프로세서 사용시간을 프로세스들에게 분배
        - 공간 분할 관리
            - 하나의 자원을 분할하여 동시에 사용
            - 예) 메모리

스케줄링의 목적

- 시스템의 성능 향상
- 대표적 시스템 성능 지표
    - 응답시간 - 작업 요청으로부터 응답을 받을때까지의 시간
    - 작업 처리량 - 단위 시간 동안 완료된 작업의 수
    - 자원 활용도 - 주어진 시간 동안 자원이 활용된 시간
- 목적에 맞는 지표를 고려하여 스케줄링 기법을 선택

![스크린샷 2021-08-25 오후 9.49.32.png](Process%20Scheduling%20Part%201%2097cfb1e02777477191d57d54c616948c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2021-08-25_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.49.32.png)

첫번째 출력 - 화면에 뭐가 나올때

스케줄링 기준 이란? 

스케줄링 기법이 고려하는 항목

- 결정을 해야 할때 A or B ? 비싼거? 성능? 을 지표
    - 프로세스의 특성에 따른
        - i/o bounded or compute-bounded
            - Cpu burst ? & i/o burst

                ![스크린샷 2021-08-25 오후 9.58.04.png](Process%20Scheduling%20Part%201%2097cfb1e02777477191d57d54c616948c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2021-08-25_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.58.04.png)

                - 프로세스 수행  = cpu 사용 + i/o 대기
                - cpu burst = cpu 사용 시간이 많은 경우 - compute bounded process
                - i/o burst = i/o 대기 시간이 많은 경우 - i/o bounded process
                - burst time 은 스케줄링의 중요한 기준 중 하나
    - 시스템 특성에 따른
        - Batch system or interactive system
    - 프로세스의 긴급성에 따른
        - hard or soft resal time, non real time systems
    - 프로세스 우선순위에 따른
    - 프로세스 총 실행 시간 등

스케줄링의 단계 

- 발생하는 빈도로 구분
    - long-term scheduling - 긴 시간에 한번씩 작업 함

        ![스크린샷 2021-08-25 오후 10.07.27.png](Process%20Scheduling%20Part%201%2097cfb1e02777477191d57d54c616948c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2021-08-25_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.07.27.png)

        - job scheduling이라고도 한다
            - 시스템에 제출 할(kernel에 등록 할) 작업(job) 결정

                ![스크린샷 2021-08-25 오후 10.11.05.png](Process%20Scheduling%20Part%201%2097cfb1e02777477191d57d54c616948c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2021-08-25_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.11.05.png)

        - 다중프로그래밍 정도(degree) 조절
            - 시스템 내에 프로세스 수 조절 - **사람으로 예를 들면 100명의 숫자의 사람을 관리 하기 힘들듯이 100개의 프로세스를 관리하기는 어렵다, 그래서 몇명 씩 프로세스를 시스템에 넣어준주는 것을 담당**
        - i/o bounded와 compute- bounded 프로세스들을 잘 섞어서 선택해야 함
            - 왜 ? **compute bounded 프로세스가 있는 것만 넣어주면 i/o bounded는 놀 것 이고
            i/o bounded 프로세스가 있는 것만 넣어주면 Cpu만 놀 것이다 이것은 자원 활용도가 떨어지는 것**
        - 시분할 시스템에서는 모든 작업을 시스템에 등록
            - 시간을 분할해서 넣어주므로 쓰이는 빈도는 적다

    - mid - term scheduling

        ![스크린샷 2021-08-25 오후 10.19.36.png](Process%20Scheduling%20Part%201%2097cfb1e02777477191d57d54c616948c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2021-08-25_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.19.36.png)

        - 메모리 할당 결정을 하는 역할
            - intermediate-level scheduling을 하며
            - Swapping(swap-in/swap-out)

                이 Swap이라는 영역은 보조저장장치, 즉 하드디스크 잡히는데 CPU가 어떠한 프로그램을

                실행하기 위해서는 해당 프로그램은 반드시 주 메모리에 있어야 한다. 그러나 주 메모리는

                그 크기가 제한적이기 때문에 만약 추가적으로 어떠한 프로그램을 실행시켜야 하는데

                주 메모리에 할당 가능한 영역이 없는 경우에는 주 메모리에 공간을 만들어줘야 한다.

                할당 가능한 영역이 없는 상태에서 메모리 공간을 만든다는 것은 한마디로 현재 주 메모리에

                존재하는 어떠한 프로그램을 삭제해야 한다

                그러면 주 메모리에서 내리고자 하는 프로그램이 정해진 상태라고 가정하면 해당 프로그램은

                완전히 프로세스가 종료가 되는 것이 아니라 대기상태에 들어가는 것. 그러므로 이전의 상태는 그대로 유지를 하고 있어야 한다.

                이러한 프로세스의 정보들이 주 메모리에서 보조저장장치에 위치한 Swap 영역으로 옮겨지는 것을 Swap-Out 이라고 하고 다시 이 정보를 보조저장장치의 Swap 영역에서 주 메모리로 옮겨가는 것을 Swap-In 이라고 한다. 그리고 Swap-In & Out 동작을 통틀어 Swapping 이라고 표현합니다.

    - short-term scheduling
        - process scheduling

            ![스크린샷 2021-08-25 오후 10.31.26.png](Process%20Scheduling%20Part%201%2097cfb1e02777477191d57d54c616948c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2021-08-25_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.31.26.png)

            - low - level  scheduling
            - 프로세서(Cpu)를 항당할 프로세스를 결정
            - 가장 빈번하게 발생
                - interrupt, block, time- out
                - 매우 빨라야 함

                    ![스크린샷 2021-08-25 오후 10.33.49.png](Process%20Scheduling%20Part%201%2097cfb1e02777477191d57d54c616948c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2021-08-25_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.33.49.png)

    스케줄링 정책

    - 선점 VS 비선점
        - preemptive scheduling, Non-preemptive scheduling
    - 우선순위
        - priority

    선점 / 비선점 스케줄링

    - 비선점 스케줄링
        - 할 받을 자원을 스스로 반납할 때까지 사용
            - 예) I/ O
    - 장점
        - context switch overhead가 적음
    - 단점
        - 잦은 우선순위 역전, 평균 응답 시간 증가

    - 선점 스케줄링
        - 타의에 의해 자원을 빼앗길 수 있음
            - 예) 할당 시간 종료, 우선순위가 높은 프로세스 등장
        - context switch overhead가 큼 → 시스템에 부하가 큼
        - time sharing system

    우선순위

    - 프로세스의 중요도
    - 정적 우선순위
        - 프로세스 생성시 결정된 우선순위가 유지 됨
        - 구현이 쉽고, 부하가 적음
        - 시스템 환경 변화에 대한 대응이 어려움

    - 동적 우선순위
        - 프로세스의 상태 변화에 따라 우선순위가 변경
        - 구현이 복잡, 우선순위 재계산 부하가 큼
        - 시스템 환경 변화에 유연한 대응 가능